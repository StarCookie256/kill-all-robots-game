# ==================================================
# file: scripts\global.gd
# ==================================================
extends Node
signal _on_hero_taked_damage(value)

# ==================================================
# file: scripts\character\Player\hand.gd
# ==================================================
extends Node2D
@onready var animated_sprite = $"../AnimatedSprite2D"
@onready var player = get_parent()
@onready var node_right = $"../NodeRight"
@onready var node_left = $"../NodeLeft"
var was_flipped = false
func _physics_process(delta: float) -> void:
	var mouse_pos = get_global_mouse_position()
	var player_pos = player.global_position
	# Определяем, в какую сторону смотрит мышь
	var is_mouse_left = mouse_pos.x < player_pos.x
	# Если направление изменилось, меняем сторону
	if is_mouse_left != was_flipped:
		was_flipped = is_mouse_left
		animated_sprite.flip_h = is_mouse_left
	# Устанавливаем позицию руки в зависимости от стороны
	if is_mouse_left:
		global_position = node_left.global_position
	else:
		global_position = node_right.global_position
	# Поворачиваем руку к мыши
	var direction = mouse_pos - global_position
	rotation = direction.angle()

# ==================================================
# file: scripts\character\Player\player.gd
# ==================================================
class_name Player extends CharacterBody2D
const SPEED = 300
const JUMP_VELOCITY = 400
@export var HP = 100
@export var HUD: CanvasLayer
@onready var sprite := $AnimatedSprite2D
@onready var left_hand: Node2D = $NodeLeft
@onready var right_hand: Node2D = $NodeRight
@onready var camera: = $Camera2D
var direction := 0
var facing_left := false
var current_hand: Node2D  # ← Тип Node2D, не WeaponBase
func _ready() -> void:
	current_hand = right_hand
	Global._on_hero_taked_damage.connect(_on_damage_received)
func _physics_process(delta: float) -> void:
	HUD.set_hp(HP)
	direction = Input.get_axis("move_left", "move_right")
	if not is_on_floor():
		velocity += get_gravity() * delta
	if Input.is_action_just_pressed("move_jump") and is_on_floor():
		velocity.y = -JUMP_VELOCITY
	velocity.x = direction * SPEED
	move_and_slide()
	_update_aim()
	_update_animations()
func _update_aim() -> void:
	var mouse_pos := get_global_mouse_position()
	facing_left = mouse_pos.x < global_position.x
	sprite.flip_h = facing_left
	if facing_left:
		current_hand = left_hand
		left_hand.visible = true
		right_hand.visible = false
	else:
		current_hand = right_hand
		left_hand.visible = false
		right_hand.visible = true
	var direction_to_mouse := mouse_pos - current_hand.global_position
	var angle := direction_to_mouse.angle()
	if facing_left:
		current_hand.rotation = angle + PI / 2
		current_hand.scale.y = -1
	else:
		current_hand.rotation = angle - PI / 2
		current_hand.scale.y = 1
func _update_animations() -> void:
	if not is_on_floor():
		sprite.play("Jump")
	elif direction != 0:
		sprite.play("Walk")
	else:
		sprite.play("Idle")
func _input(event: InputEvent) -> void:
	if event.is_action_pressed("shoot"):
		# Получаем оружие из текущей руки
		var gun := current_hand.get_node("Weapon/Pistol") as WeaponBase
		if gun:
			gun.shoot()
func _on_damage_received(damage: int) -> void:
	HP -= damage

# ==================================================
# file: scripts\character\Robots\Anton\robot.gd
# ==================================================
extends CharacterBody2D
const SPEED := 120
@onready var sprite := $AnimatedSprite2D
@onready var player := $"../Player"  # Путь к игроку в сцене
func _physics_process(delta):
	# Гравитация
	if not is_on_floor():
		velocity += get_gravity() * delta
	# Определяем направление к игроку
	var direction = 0
	if player:
		if player.global_position.x > global_position.x+10:
			direction = 1  # идем вправо
		elif player.global_position.x < global_position.x-10  :
			direction = -1  # идем влево
	# Движение
	velocity.x = SPEED * direction
	if direction != 0:
		sprite.play("Walk")
		sprite.flip_h = direction < 0  # переворачиваем спрайт при движении влево
	else:
		sprite.stop()
	move_and_slide()

# ==================================================
# file: scripts\Enemies\enemy_base.gd
# ==================================================
class_name Enemy extends CharacterBody2D
@export var SPEED: float = 120
@export var HP: float = 10
@export var MAX_HP: float = 10
@export var DEF: float = 0
@export var DMG: float = 5
@onready var sprite := $AnimatedSprite2D
@onready var player := $"../Player" 
@onready var stopAll := false
@onready var playerExited := true
@onready var hp_bar = $TextureProgressBar
func _ready() -> void:
	hp_bar.max_value = MAX_HP
func _physics_process(delta: float) -> void:
	hp_bar.value = HP
	if stopAll:
		return
	if HP <= 0:
		await _die()
	if not is_on_floor():
		velocity += get_gravity() * delta
	_move()
func _move() -> void:
# Определяем направление к игроку
	var direction = 0
	if player:
		if player.global_position.x > global_position.x+5:
			direction = 1  # идем вправо
		elif player.global_position.x < global_position.x-5:
			direction = -1  # идем влево
	# Движение
	velocity.x = SPEED * direction
	if direction != 0:
		sprite.play("Walk")
		sprite.flip_h = direction < 0  # переворачиваем спрайт при движении влево
	else:
		sprite.stop()
	move_and_slide()
func _attack() -> void:
	print("Попался халяль")
	Global._on_hero_taked_damage.emit(DMG)
func _take_damage(damage: float) -> void:
	print('АААААААААААААААААААААААААААААААААААЙ')
	HP -= damage
func _die() -> void:
	stopAll = true
	sprite.play("Death")
	await sprite.animation_finished
	sprite.stop()
	queue_free()

# ==================================================
# file: scripts\Enemies\Melee Normal Robot\melee_normal_robot.gd
# ==================================================
extends "res://scripts/Enemies/enemy_base.gd"
@onready var leftAttack = $AnimatedSprite2D/HitLeft
@onready var rightAttack = $AnimatedSprite2D/HitRight
@onready var playerHitTimer = $PlayerHitTimer
func _physics_process(delta: float) -> void:
	hp_bar.value = HP
	if stopAll:
		return
	if HP <= 0:
		await _die()
	if not is_on_floor():
		velocity += get_gravity() * delta
	if sprite.flip_h:
		rightAttack.monitoring = false
		rightAttack.monitorable = false
		leftAttack.monitoring = true
		leftAttack.monitorable = true
	else:
		rightAttack.monitoring = true
		rightAttack.monitorable = true
		leftAttack.monitoring = false
		leftAttack.monitorable = false
	_move()
func _attack() -> void:
	print("Попался халяль")
	while !playerExited && HP > 0:
		sprite.play("Attack")
		playerHitTimer.start()
		await playerHitTimer.timeout
		if !playerExited:
			Global._on_hero_taked_damage.emit(DMG)
		await sprite.animation_finished
		sprite.stop()
func _on_hit_body_shape_entered(_body_rid: RID, _body: Node2D, _body_shape_index: int, _local_shape_index: int) -> void:
	if _body is Player:
		playerExited = false # игрок еще находится в зоне атаки
		stopAll = true
		await _attack()
		stopAll = false
func _on_hit_body_shape_exited(_body_rid: RID, _body: Node2D, _body_shape_index: int, _local_shape_index: int) -> void:
	playerExited = true # игрок вышел из зоны

# ==================================================
# file: scripts\Enemies\Melee Wrecked Robot\melee_wrecked_robot.gd
# ==================================================
extends "res://scripts/Enemies/enemy_base.gd"
@onready var leftAttack = $AnimatedSprite2D/HitLeft
@onready var rightAttack = $AnimatedSprite2D/HitRight
@onready var playerHitTimer = $PlayerHitTimer
func _physics_process(delta: float) -> void:
	hp_bar.value = HP
	if stopAll:
		return
	if HP <= 0:
		await _die()
	if not is_on_floor():
		velocity += get_gravity() * delta
	if sprite.flip_h:
		rightAttack.monitoring = false
		rightAttack.monitorable = false
		leftAttack.monitoring = true
		leftAttack.monitorable = true
	else:
		rightAttack.monitoring = true
		rightAttack.monitorable = true
		leftAttack.monitoring = false
		leftAttack.monitorable = false
	_move()
func _attack() -> void:
	print("Попался халяль")
	while !playerExited && HP > 0:
		sprite.play("Attack")
		playerHitTimer.start()
		await playerHitTimer.timeout
		if !playerExited:
			Global._on_hero_taked_damage.emit(DMG)
		await sprite.animation_finished
		sprite.stop()
func _on_hit_body_shape_entered(_body_rid: RID, _body: Node2D, _body_shape_index: int, _local_shape_index: int) -> void:
	if _body is Player:
		playerExited = false # игрок еще находится в зоне атаки
		stopAll = true
		await _attack()
		stopAll = false
func _on_hit_body_shape_exited(_body_rid: RID, _body: Node2D, _body_shape_index: int, _local_shape_index: int) -> void:
	playerExited = true # игрок вышел из зоны

# ==================================================
# file: scripts\Enemies\Police Robot\police_robot.gd
# ==================================================
extends "res://scripts/Enemies/enemy_base.gd"
@export var CHARGE_SPEED: float = 500
@onready var detectionAnimTimer = $DetectionAnimTimer
@onready var chargeAnimTimer = $ChargeAnimTimer
@onready var charging: bool = false
@onready var charge_direction: int = 1
@onready var detected: bool = false
@onready var hitBox = $HitBox
func _ready() -> void:
	hp_bar.max_value = MAX_HP
	DMG = 10
	hitBox.monitorable = false
	hitBox.monitoring = false
func _physics_process(delta: float) -> void:
	hp_bar.value = HP
	if stopAll:
		return
	if HP <= 0:
		await _die()
	if not is_on_floor():
		velocity += get_gravity() * delta
	if charging:
		_charged_move()
	else:
		_move()
func _on_vision_body_shape_entered(_body_rid: RID, body: Node2D, _body_shape_index: int, _local_shape_index: int) -> void:
	if !detected && body is Player:
		stopAll = true
		detected = true
		sprite.play("Start Attack")
		if player:
			if player.global_position.x > global_position.x:
				charge_direction = 1  # идем вправо
			elif player.global_position.x < global_position.x:
				charge_direction = -1  # идем влево
		detectionAnimTimer.start()
func _on_detection_anim_timer_timeout() -> void:
	stopAll = false
	charging = true
	hitBox.monitorable = true
	hitBox.monitoring = true
	chargeAnimTimer.start()
func _charged_move() -> void:
	# Движение
	velocity.x = CHARGE_SPEED * charge_direction
	if charge_direction != 0:
		sprite.play("Attack")
		sprite.flip_h = charge_direction < 0  # переворачиваем спрайт при движении влево
	else:
		sprite.stop()
	move_and_slide()
func _on_charge_anim_timer_timeout() -> void:
	HP = 0
	await _die()
func _on_hit_box_body_entered(body: Node2D) -> void:
	if body is Player:
		HP = 0
		Global._on_hero_taked_damage.emit(DMG)
		await _die()

# ==================================================
# file: scripts\Enemies\Rocket Robot\rocket_projectile.gd
# ==================================================
extends RigidBody2D
@export var SPEED: float = 400
@export var DMG: float = 10
@export var GRAVITY: float = 980.0  # Гравитация проекта
@onready var sprite = $Sprite2D
@onready var spriteAnimation = $AnimatedSprite2D
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	spriteAnimation.hide()
	# Включаем отслеживание столкновений
	contact_monitor = true
	max_contacts_reported = 1
# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	if linear_velocity.length() > 0.1:
		var target_angle = linear_velocity.angle()
		rotation = lerp_angle(rotation, target_angle, 10.0*delta)
func shoot(player_pos: Vector2) -> void:
	var arc_height: float = _calculate_arc_height_for_target(global_position, player_pos, SPEED)
	var vertical_force = Vector2(0, -arc_height)
	var direction: Vector2 = (player_pos - global_position).normalized()
	apply_impulse((direction * SPEED)+vertical_force)
func _calculate_arc_height_for_target(start_pos: Vector2, target_pos: Vector2, speed: float) -> float:
	var g = ProjectSettings.get_setting("physics/2d/default_gravity")  # Обычно 980
	var dx = target_pos.x - start_pos.x
	var dy = target_pos.y - start_pos.y
	if abs(dx) < 0.1:  # Почти вертикальный выстрел
		return abs(dy) * 2.0
	var angle = deg_to_rad(45)
	var cos_angle = cos(angle)
	var cos_squared = cos_angle * cos_angle
	var denominator = 2 * cos_squared * (dx - dy)
	if denominator <= 0:
		# Невозможно попасть под 45°, увеличиваем угол
		return abs(dx) * 1.2 + abs(dy) * 1.5
	# 3. Вычисляем необходимую скорость
	var needed_speed_squared = (g * dx * dx) / denominator
	var needed_speed = sqrt(abs(needed_speed_squared))
	# 4. Если наша скорость меньше необходимой, нужно увеличить высоту дуги
	var speed_ratio = needed_speed / speed
	# 5. Высота параболы: H = (v² * sin²θ) / (2g)
	var base_height = (speed * speed * sin(angle) * sin(angle)) / (2 * g)
	var corrected_height = base_height * speed_ratio * 1.5
	# 7. Учитываем разницу высот
	if dy < 0:  # Цель ВЫШЕ
		corrected_height += abs(dy) * 1.2
	else:  # Цель НИЖЕ
		corrected_height += dy * 0.6  # Все равно добавляем, но меньше
	# 8. Учитываем горизонтальное расстояние
	corrected_height += abs(dx) * 1.1
	# 9. Ограничиваем разумными значениями
	return clamp(corrected_height, 100.0, 1500.0)
func _on_body_entered(_body: Node) -> void:
	sprite.hide()
	spriteAnimation.show()
	spriteAnimation.play("Explode")
	print('БУУУУУУУУУУУУУУУУУМ *щелчок демона-бомбы')
	await spriteAnimation.animation_finished
	queue_free()

# ==================================================
# file: scripts\Enemies\Rocket Robot\rocket_robot.gd
# ==================================================
extends "res://scripts/Enemies/enemy_base.gd"
@onready var shotMarker: = $AnimatedSprite2D/ShotMarkerRight
@onready var rocket_scene = preload("res://scenes/Enemies/Rocket Robot/rocket_projectile.tscn")
@onready var attackStartTimer = $AttackStartTimer
func _attack() -> void:
	while !playerExited && HP > 0:
		if player.global_position.x > global_position.x+10:
			sprite.flip_h = false
		elif player.global_position.x < global_position.x-10:
			sprite.flip_h = true
		shotMarker = $AnimatedSprite2D/ShotMarkerLeft if sprite.flip_h else $AnimatedSprite2D/ShotMarkerRight
		sprite.play("Attack")
		# ждем когда робот подымет пушку для выпуска снаряда
		attackStartTimer.start() 
		await attackStartTimer.timeout
		var player_pos:Vector2 = player.global_position
		var rocket = rocket_scene.instantiate()
		get_parent().add_child(rocket)
		rocket.global_position = shotMarker.global_position
		#rocket.rotation = shotMarker.rotation
		rocket.shoot(player_pos)
		await sprite.animation_finished
		sprite.stop()
func _on_visible_on_screen_notifier_2d_screen_entered() -> void:
	print('щас тя бомбить буим')
	playerExited = false # игрок еще находится в зоне атаки
	stopAll = true
	await _attack()
	stopAll = false
func _on_visible_on_screen_notifier_2d_screen_exited() -> void:
	playerExited = true

# ==================================================
# file: scripts\HUD\hud.gd
# ==================================================
extends CanvasLayer
@export var MAX_VALUE: int =  100
@onready var playerTakedDamageScene = preload("res://scenes/HUD/player_taked_damage.tscn")
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	Global._on_hero_taked_damage.connect(_taked_damage_anim)
# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	pass
func set_hp(new_hp) -> void:
	%HeroHP.value = 100.0/MAX_VALUE * new_hp
func _taked_damage_anim(damage: int) -> void:
	var newLabel = playerTakedDamageScene.instantiate()
	add_child(newLabel)
	newLabel.get_node("TakedDamageControl/TakedDamageLabel").text = "- "+str(damage)
	newLabel.get_node("TakedDamageControl/TakedDamageAnim").play("player_damage")
	await newLabel.get_node("TakedDamageControl/TakedDamageAnim").animation_finished
	newLabel.queue_free()

# ==================================================
# file: scripts\Main\main.gd
# ==================================================
extends Node2D
@onready var mobTimer = $MobTimer
@onready var leftPortal = $LeftPortal
@onready var rightPortal = $RightPortal
@onready var policeRobotScene = preload("res://scenes/Enemies/Police Robot/police_robot.tscn")
@onready var meleeNormalRobotScene = preload("res://scenes/Enemies/Melee Normal Robot/melee_normal_robot.tscn")
@onready var meleeWreckedRobotScene = preload("res://scenes/Enemies/Melee Wrecked Robot/melee_wrecked_robot.tscn")
# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	pass # Replace with function body.
# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	pass
func _on_mob_timer_timeout() -> void:
	var mobLeft = meleeNormalRobotScene.instantiate()
	add_child(mobLeft)
	mobLeft.global_position = leftPortal.global_position
	var mobRight = meleeWreckedRobotScene.instantiate()
	add_child(mobRight)
	mobRight.global_position = rightPortal.global_position

# ==================================================
# file: scripts\Weapons\weapon_base.gd
# ==================================================
class_name WeaponBase extends Node2D
@export var shoot_interval: float = 0.01
@export var bullet: PackedScene
@export var bullet_spawnpoint: Node2D
func shoot():
	var bullet_instance: BulletBase = bullet.instantiate()
	bullet_instance.global_position = bullet_spawnpoint.global_position
	bullet_instance.direction = (bullet_spawnpoint.global_position
		- global_position).normalized()
	get_tree().current_scene.get_node("BulletsContainer").add_child(bullet_instance)

# ==================================================
# file: scripts\Weapons\Bullets\bullet_base.gd
# ==================================================
class_name BulletBase extends Area2D
@export var direction: Vector2
@export var speed: float = 800.0
@export var damage: float = 1.0
func _process(delta: float) -> void:
	global_position += direction * speed * delta
func _on_body_entered(body: Node2D) -> void:
	# код для нанесения урона
	if body is Enemy:
		body._take_damage(damage)

